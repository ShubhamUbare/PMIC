/**********************************************************************************************************************
 * \file TLF_Main_SM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
#include "TLF35584_Driver.h"

// --- Global FSM Variables ---
static TlfMcuState_t currentMcuState = MCU_STATE_POWER_ON;
static TlfMcuState_t requestedMcuState = MCU_STATE_INITIALIZE;
static TlfPmicState_t lastPmicState = TLF_PMIC_STATE_POWERDOWN;

// --- Function Prototypes for Handlers ---
static void TLF_Handler_PowerOn(void);
static void TLF_Handler_Initialize(void);
static void TLF_Handler_NormalRun(void);
static void TLF_Handler_TransitionWait(void);
static void TLF_Handler_StandbyPrepare(void);
static void TLF_Handler_SleepPrepare(void);
static void TLF_Handler_FailSafeRecovery(void);

// --- Public APIs (Requested GoTo functions) ---

void TLF_Request_GoToNormal(void)
{
    // Application requests transition to Normal mode
    requestedMcuState = MCU_STATE_NORMAL_RUN;
}

void TLF_Request_GoToStandby(void)
{
    // Application requests transition to Standby mode
    requestedMcuState = MCU_STATE_STANDBY_PREPARE;
}

void TLF_Request_GoToSleep(void)
{
    // Application requests transition to Sleep mode
    requestedMcuState = MCU_STATE_SLEEP_PREPARE;
}

// --- FSM Handler Implementations ---

/**
 * @brief Handles the initial power-up state after a system reset (via ROT).
 */
static void TLF_Handler_PowerOn(void)
{
    // 1. Log the last reset cause by reading PMIC status registers [1]
    uint16 fail_flags = TLF_ReadRegister(TLF_REG_SYSFAIL);
    //... Log fail_flags for diagnostics...

    // 2. Immediately transition to initialization where WWD must be serviced.
    currentMcuState = MCU_STATE_INITIALIZE;
}

/**
 * @brief Handles PMIC initialization and mandatory WWD start-up service.
 */
static void TLF_Handler_Initialize(void)
{
    // WWD is active by default in INIT state, requiring immediate service. [3]
    TLF_ServiceWwd();
    MCU_Service_Internal_Wdt(); // Service internal CPU WDT

    // 1. Initialize QSPI peripheral (TC387 iLLDs)
    // IfxQspi_SpiMaster_init(&g_qspiConfig);

    // 2. Configure PMIC safety parameters (e.g., WWD timing, LDO enable, etc.)
    // This uses the protected write sequence.
    TLF_ProtectedWriteConfig(TLF_REG_DEVCFG0, 0xXX);
    TLF_ProtectedWriteConfig(TLF_REG_DEVCFG2, 0xYY);

    // 3. Request transition to the desired operational mode (usually NORMAL)
    if (TLF_SetStateRequest(TLF_CMD_NORMAL))
    {
        currentMcuState = MCU_STATE_TRANSITION_WAIT;
        requestedMcuState = MCU_STATE_NORMAL_RUN;
    }
    else
    {
        // Re-try configuration or log an error and wait for reset
    }
}

/**
 * @brief The full operational state (LDOs/Regulators ON, full supervision).
 */
static void TLF_Handler_NormalRun(void)
{
    // 1. Main Application Logic
    //... Run core control loops, sensor reading, communication stacks...

    // 2. WWD Service (Gated by PFM)
    // WWD must only be serviced if all safety-critical tasks have completed successfully
    // in the current cycle, ensuring logical supervision. [6, 7]
    if (PFM_Check_Passed())
    {
        TLF_ServiceWwd();
    }
    // If PFM check fails, the WWD is intentionally starved, forcing a PMIC reset.

    MCU_Service_Internal_Wdt();

    // 3. Monitor PMIC Status
    lastPmicState = TLF_CheckPmicStatus();
    if (lastPmicState == TLF_PMIC_STATE_FAILSAFE)
    {
        currentMcuState = MCU_STATE_FAILSAFE_RECOVERY;
    }
    else if (lastPmicState == TLF_PMIC_STATE_WAKE) // WAKE state should request return to NORMAL
    {
        TLF_SetStateRequest(TLF_CMD_NORMAL);
        currentMcuState = MCU_STATE_TRANSITION_WAIT;
        requestedMcuState = MCU_STATE_NORMAL_RUN;
    }

    // 4. Check for requested state change from the application layer
    if (requestedMcuState!= MCU_STATE_NORMAL_RUN && requestedMcuState!= MCU_STATE_INITIALIZE)
    {
        currentMcuState = requestedMcuState;
    }
}

/**
 * @brief Initiates transition to STANDBY mode.
 */
static void TLF_Handler_StandbyPrepare(void)
{
    // 1. Perform MCU power-down tasks (e.g., store data to non-volatile memory)
    //...

    // 2. Request STANDBY transition via complementary write
    if (TLF_SetStateRequest(TLF_CMD_STANDBY))
    {
        currentMcuState = MCU_STATE_TRANSITION_WAIT;
        requestedMcuState = MCU_STATE_STANDBY_PREPARE; // Use this to track the target state
    }
    // Note: If WAK/ENA is triggered during NORMAL->STANDBY transition,
    // PMIC aborts and moves to INIT (triggers ROT reset). [1]
    // The system relies on the subsequent reset and boot-up to re-enter INIT handler.
}

/**
 * @brief Initiates transition to SLEEP mode.
 */
static void TLF_Handler_SleepPrepare(void)
{
    // SLEEP requires LDO_uC current to drop below a threshold (CMONEN mode) or a timer delay. [2]

    // 1. Ensure minimal MCU current consumption
    //... Disable unnecessary peripherals, set clocks low...

    // 2. Request SLEEP transition via complementary write
    if (TLF_SetStateRequest(TLF_CMD_SLEEP))
    {
        currentMcuState = MCU_STATE_TRANSITION_WAIT;
        requestedMcuState = MCU_STATE_SLEEP_PREPARE;
    }
}

/**
 * @brief Waits for the PMIC to confirm the requested state transition.
 */
static void TLF_Handler_TransitionWait(void)
{
    // WWD service must continue during transition latency to prevent timeout. [8]
    TLF_ServiceWwd();
    MCU_Service_Internal_Wdt();

    TlfPmicState_t targetPmicState = TLF_PMIC_STATE_NORMAL;
    TlfMcuState_t nextMcuState = MCU_STATE_NORMAL_RUN;

    // Determine the expected PMIC state based on the requested MCU state
    if (requestedMcuState == MCU_STATE_STANDBY_PREPARE)
    {
        targetPmicState = TLF_PMIC_STATE_STANDBY;
        // In this case, the MCU is effectively going to shut down or enter a low-power loop
        nextMcuState = MCU_STATE_STANDBY_PREPARE;
    }
    else if (requestedMcuState == MCU_STATE_SLEEP_PREPARE)
    {
        targetPmicState = TLF_PMIC_STATE_SLEEP;
        nextMcuState = MCU_STATE_SLEEP_PREPARE;
    }

    // Check PMIC status
    lastPmicState = TLF_CheckPmicStatus();

    if (lastPmicState == targetPmicState)
    {
        // Transition complete. Move to the next operational state.
        currentMcuState = nextMcuState;
    }
    else if (lastPmicState == TLF_PMIC_STATE_FAILSAFE)
    {
        // Transition aborted by critical PMIC failure.
        currentMcuState = MCU_STATE_FAILSAFE_RECOVERY;
    }
    // Add logic here to check for transition timeout.
}

/**
 * @brief PMIC detected a critical failure (WWD failure, OV, UV > tStG).
 */
static void TLF_Handler_FailSafeRecovery(void)
{
    // 1. Read and log all failure registers (MONSF0, MONSF1, MONSF2, SYSFAIL)
    // The PMIC is expected to assert ROT low (System Reset) very quickly.
    // The MCU can only wait for the guaranteed reset pulse. [9]

    // Do NOT service WWD or internal WDTs in this state.
    // Loop until the ROT signal forces a hard reset, returning the system to MCU_STATE_POWER_ON.
    while(1) { /* Wait for inevitable reset */ }
}

/**
 * @brief Main FSM Execution Function (Called periodically by the RTOS/Task scheduler).
 */
void TLF_State_Machine_Run(void)
{
    // Continuous WWD check: If the PMIC autonomously failed, transition to recovery.
    if (currentMcuState!= MCU_STATE_FAILSAFE_RECOVERY)
    {
        TlfPmicState_t pmic_state = TLF_CheckPmicStatus();
        if (pmic_state == TLF_PMIC_STATE_FAILSAFE)
        {
            currentMcuState = MCU_STATE_FAILSAFE_RECOVERY;
        }
    }

    switch (currentMcuState)
    {
        case MCU_STATE_POWER_ON:
            TLF_Handler_PowerOn();
            break;
        case MCU_STATE_INITIALIZE:
            TLF_Handler_Initialize();
            break;
        case MCU_STATE_NORMAL_RUN:
            TLF_Handler_NormalRun();
            break;
        case MCU_STATE_STANDBY_PREPARE:
        case MCU_STATE_SLEEP_PREPARE:
            // Handled by the dedicated 'Prepare' functions before entering wait
            if (currentMcuState == MCU_STATE_STANDBY_PREPARE) TLF_Handler_StandbyPrepare();
            if (currentMcuState == MCU_STATE_SLEEP_PREPARE) TLF_Handler_SleepPrepare();
            // Fallthrough to transition wait will occur if request was successful
            break;
        case MCU_STATE_TRANSITION_WAIT:
            TLF_Handler_TransitionWait();
            break;
        case MCU_STATE_FAILSAFE_RECOVERY:
            TLF_Handler_FailSafeRecovery();
            break;
        default:
            // Unexpected state: force fail-safe transition
            currentMcuState = MCU_STATE_FAILSAFE_RECOVERY;
            break;
    }
}


// --- Placeholder Functions for External System Integration ---

/**
 * @brief Placeholder for the Program Flow Monitoring check.
 * Must return 1 only if all critical application tasks completed successfully.
 */
uint8 PFM_Check_Passed(void)
{
    // *** IMPLEMENTATION REQUIRED: CHECK ALL TASK HEARTBEATS ***
    return 1; // Mock: always pass
}

/**
 * @brief Placeholder for the internal AURIX WDT service.
 */
void MCU_Service_Internal_Wdt(void)
{
    // Service AURIX internal CPU WDT (e.g., IfxScuWdt_serviceCpuWatchdog(password))
}

/**
 * @brief Placeholder for servicing the system WDT, often done concurrently with the external WWD.
 */
void PFM_Service_System_Wwd(void)
{
    // Service AURIX internal Safety Watchdog Timer (WDT)
}
