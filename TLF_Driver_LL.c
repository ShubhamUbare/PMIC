/**********************************************************************************************************************
 * \file TLF_Driver_LL.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
#include "TLF35584_Driver.h"
#include <string.h> // For memcpy, memset

// --- QSPI and MCU Driver Placeholder Implementations ---

// NOTE: These functions must be implemented using the AURIX QSPI iLLDs.
// They handle the 16-bit transaction format (Address + Data + Parity) required
// by the TLF35584 SPI protocol.

/**
 * @brief Placeholder for the actual QSPI exchange function.
 * @param txData 16-bit word to transmit (Address + Data + Parity)
 * @return 16-bit response from PMIC (Status + Read Data + Parity)
 */
static inline uint16 QSPI_Exchange(uint16 txData)
{
    // *** Placeholder implementation using AURIX iLLDs ***
    // This typically involves:
    // 1. Calculating the odd parity bit for txData.
    // 2. Packaging the 16-bit command/data word.
    // 3. Calling IfxQspi_SpiMaster_exchange() for 16-bit transaction.
    // 4. Verifying the odd parity bit on the received word.
    // 5. Returning the extracted data byte.

    // Abstracting for demonstration: Assume successful read/write
    return (uint16)(txData + 0x01); // Mock response
}

// --- Driver Core Functions ---

/**
 * @brief Reads a 8-bit data register from the PMIC.
 * @param regAddress Register address (0x00 to 0x3F)
 * @return 16-bit SPI response word (contains Status + Data)
 */
uint16 TLF_ReadRegister(uint8 regAddress)
{
    uint16 tx_command;
    // Format: 15 (R/W), 14:8 (Address), 7:0 (Data/Don't Care)
    // R/W = 1 for Read
    tx_command = (1U << 15) | ((uint16)regAddress << 8);
    return QSPI_Exchange(tx_command);
}

/**
 * @brief Writes an 8-bit data value to a standard PMIC register.
 */
static inline uint16 TLF_WriteRegister(uint8 regAddress, uint8 data)
{
    uint16 tx_command;
    // Format: 15 (R/W), 14:8 (Address), 7:0 (Data)
    // R/W = 0 for Write
    tx_command = ((uint16)regAddress << 8) | data;
    return QSPI_Exchange(tx_command);
}

/**
 * @brief Implements the mandatory high-integrity complementary write for state transitions.
 * Writes to DEVCTRL and DEVCTRLN (bit-wise inverted) in sequence.
 * @param stateReqValue The desired state command (e.g., TLF_CMD_NORMAL)
 * @return 1 if successful, 0 otherwise
 */
uint8 TLF_SetStateRequest(uint8 stateReqValue)
{
    uint8 stateReqInverted = ~stateReqValue;

    // 1. Write DEVCTRL: R/W=0, Addr=0x04, Data=stateReqValue
    TLF_WriteRegister(TLF_REG_DEVCTRL, stateReqValue);

    // 2. Write DEVCTRLN: R/W=0, Addr=0x05, Data=stateReqInverted
    // The PMIC validates DEVCTRLN = NOT(DEVCTRL) to confirm integrity. [1, 4]
    uint16 response = TLF_WriteRegister(TLF_REG_DEVCTRLN, stateReqInverted);

    // Check status registers for NO_OP flag (indicating complementary write failure)
    // Abstraction: Assume success if SPI exchange completes
    if (response!= 0xAAAA) // Example check
    {
        return 1; // Success
    }
    return 0; // Failure (PMIC ignores request)
}

/**
 * @brief Implements the Read-Invert-Write protocol for WWD servicing.
 * Must be executed within the PMIC's open window time.
 * @return 1 if successful, 0 if failure (outside window or protocol error)
 */
uint8 TLF_ServiceWwd(void)
{
    // WWDSCMD (0x17H) protocol: Read register to get TRIG_STATUS, then write
    // the inverted value to the TRIG bit to acknowledge the PMIC's expectation. [1]

    uint16 read_response;
    uint8 current_trigger_status;
    uint8 service_command_data;

    // 1. Read WWDSCMD (0x17H) to get the PMIC's expected trigger status.
    read_response = TLF_ReadRegister(TLF_REG_WWDSCMD);

    // Assuming TRIG_STATUS is the LSB of the data payload (actual position is datasheet dependent)
    current_trigger_status = (uint8)(read_response & 0x01);

    // 2. Calculate the required inverted value for the next service.
    service_command_data = (~current_trigger_status) & 0x01;

    // 3. Write the inverted value back to WWDSCMD (0x17H).
    TLF_WriteRegister(TLF_REG_WWDSCMD, service_command_data);

    PFM_Service_System_Wwd(); // Service internal AURIX WDTs concurrently [5]

    return 1; // Assuming successful SPI transaction and timing check
}

/**
 * @brief Reads the PMIC's current operating state from DEVSTAT.
 * @return Current PMIC state enum.
 */
TlfPmicState_t TLF_CheckPmicStatus(void)
{
    uint16 response = TLF_ReadRegister(TLF_REG_DEVSTAT);
    // Assuming PMIC state is encoded in a specific bit field (e.g., bits 7:4 or similar).
    // Abstracting: Extract the state value.
    uint8 state_val = (uint8)((response >> 4) & 0x0F);

    // Basic mapping for known states (actual mapping is datasheet dependent)
    switch (state_val) {
        case 0x03: return TLF_PMIC_STATE_INIT;
        case 0x04: return TLF_PMIC_STATE_NORMAL;
        case 0x05: return TLF_PMIC_STATE_STANDBY;
        case 0x06: return TLF_PMIC_STATE_SLEEP;
        case 0x07: return TLF_PMIC_STATE_WAKE;
        case 0x08: return TLF_PMIC_STATE_FAILSAFE;
        default: return TLF_PMIC_STATE_POWERDOWN;
    }
}

/**
 * @brief Writes configuration to a protected register (e.g., DEVCFG0, DEVCFG2).
 * Requires the Unlock/Write/Lock sequence via the PROTCFG register.
 */
void TLF_ProtectedWriteConfig(uint8 regAddress, uint8 data)
{
    // This is a highly critical function (R2 registers like DEVCFG0/2)
    // *** Placeholder implementation using assumption ***

    // 1. Unlock command (Write specific sequence to PROTCFG)
    TLF_WriteRegister(0x03, 0xAA); // Example Unlock

    // 2. Write the configuration data
    TLF_WriteRegister(regAddress, data);

    // 3. Lock command
    TLF_WriteRegister(0x03, 0x55); // Example Lock

    // In a real application, the MCU would read back the register value (DEVCFG0/2)
    // to confirm the write operation was successful before proceeding.
}
